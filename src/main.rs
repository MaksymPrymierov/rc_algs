/*!
# MP Algs

This application generates a vector of 1000 random i32 values, and then sorts it using four different
sorting algorithms - bubble sort, shaker sort, insertion sort, and gnome sort - implemented in a
separate module. The sort_array function is responsible for sorting the vector using the specified
sorting method, and the main function calls it for each sorting method. The code also times how
long each sorting method takes to complete and prints the results.
*/

use rand::Rng;
use std::cmp::Ordering;
use std::time::Instant;

mod sort;

/**
Main

Main function that generates a vector of 1000 random integers and performs
four sorting algorithms (`bubble_sort`, `shaker_sort`, `insertion_sort`, `gnome_sort`) on the
vector using the `sort_array()` function. The results of each sorting algorithm, including the time
taken for each sorting, are printed to the console.
**/
fn main() {
    let mut values: Vec<i32> = Vec::new();
    fill_vector_with_rand_values(&mut values, 1000);

    let mut values_for_sort = values.clone();
    sort_array(&mut values_for_sort, &sort::bubble_sort, "Bubble Sort");

    let mut values_for_sort = values.clone();
    sort_array(&mut values_for_sort, &sort::shaker_sort, "Shaker Sort");

    let mut values_for_sort = values.clone();
    sort_array(
        &mut values_for_sort,
        &sort::insertion_sort,
        "Insertion Sort",
    );

    let mut values_for_sort = values.clone();
    sort_array(&mut values_for_sort, &sort::gnome_sort, "Gnome Sort");
}

/**
Generate random number

This is a function that generates a random integer value between 0 and 99 (inclusive) using the
`rand` crate's `thread_rng` method and the `gen_range` method. The function returns the generated
random value as an i32 integer.
**/
fn get_rand_value() -> i32 {
    rand::thread_rng().gen_range(0..100)
}

/**
Fill vector with rand values

The function takes a mutable reference to a vector of i32 values and a
count, and fills the vector with count random values generated by calling the `get_rand_value`
function. It does this by repeatedly pushing random values to the end of the vector.
**/
fn fill_vector_with_rand_values(vector: &mut Vec<i32>, count: usize) {
    for _ in 0..count {
        vector.push(get_rand_value());
    }
}

/**
Sort array

The function takes a mutable reference to a vector of i32 values, a reference to a
function that implements a sorting algorithm on the vector, and a string that identifies the
sorting algorithm. The function then prints a header message to the console, indicating that the
sort is starting, and measures the time taken to perform the sort by calling Instant::now(). It
then applies the sorting algorithm by calling the function passed as a reference, and printing a
message indicating the sort is complete along with the elapsed time. Finally, it prints another
header message.
**/
fn sort_array(vector: &mut Vec<i32>, sort_method: &dyn Fn(&mut Vec<i32>, Ordering), name: &str) {
    println!("-----------------------------------------------------------------------------------");
    //println!("Array Before Sorting\n{:?}", &vector);
    println!("\n{} start...", name);
    let time = Instant::now();

    sort_method(vector, Ordering::Greater);

    println!("{} finish with time {:?}", name, Instant::now() - time);
    //println!("\nArray After Sorting\n{:?}", &vector);
    println!("-----------------------------------------------------------------------------------");
}
