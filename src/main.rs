/*!
# MP Algs

This application generates a vector of 1000 random i32 values, and then sorts it using four different
sorting algorithms - bubble sort, shaker sort, insertion sort, and gnome sort - implemented in a
separate module. The sort_array function is responsible for sorting the vector using the specified
sorting method, and the main function calls it for each sorting method. The code also times how
long each sorting method takes to complete and prints the results.
*/

use crate::sort::{bubble_sort, gnome_sort, insertion_sort, merge_sort, shaker_sort};
use rand::Rng;
use std::cmp::Ordering;
use std::process;
use std::time::Instant;
use structopt::StructOpt;

mod sort;

#[derive(StructOpt, Debug)]
#[structopt(name = "MP Algs")]
struct Opt {
    /// Display data
    #[structopt(short, long)]
    verbose: bool,

    /// Sort algorithm (bubble, shaker, insertion, gnome, merge)
    #[structopt(short, long, default_value = "bubble")]
    sort: String,

    /// Number of elements
    #[structopt(short, long, default_value = "10")]
    count: usize,

    /// Sort order (ascending, descending)
    #[structopt(short, long, default_value = "ascending")]
    order: String,
}

/**
Main

Main function generates an array of random numbers of the specified length using the sorting
algorithm specified in the command line arguments, and then sorts that array.
**/
fn main() {
    let opt = Opt::from_args();

    let mut values: Vec<i32> = Vec::new();
    fill_vector_with_rand_values(&mut values, opt.count);

    let order = match opt.order.as_str() {
        "ascending" => Ordering::Greater,
        "descending" => Ordering::Less,
        _ => {
            println!("Error: \"{}\" is incorrect ordering", opt.order);
            process::exit(1);
        }
    };

    sort(&mut values.clone(), &opt.sort, opt.verbose, order);
}

/**
Generate random number

This is a function that generates a random integer value between 0 and 99 (inclusive) using the
`rand` crate's `thread_rng` method and the `gen_range` method. The function returns the generated
random value as an i32 integer.
**/
fn get_rand_value() -> i32 {
    rand::thread_rng().gen_range(0..100)
}

/**
Fill vector with rand values

The function takes a mutable reference to a vector of i32 values and a
count, and fills the vector with count random values generated by calling the `get_rand_value`
function. It does this by repeatedly pushing random values to the end of the vector.
**/
fn fill_vector_with_rand_values(vector: &mut Vec<i32>, count: usize) {
    for _ in 0..count {
        vector.push(get_rand_value());
    }
}

/**
Sort the array

This function takes a mutable reference to a vector of i32 elements to
sort, a string indicating the sorting algorithm to use, a boolean value indicating verbose output,
and an Ordering value indicating the sort order. The function prints the array before sorting if
verbose is enabled and then sorts the array using the specified algorithm. After the sort is
complete, the function prints the sorting time and the array after sorting if verbose is enabled.
If the specified sorting algorithm is not recognized, an error message is printed, and the program
is terminated.
**/
fn sort(vector: &mut Vec<i32>, sort: &str, verbose: bool, order: Ordering) {
    if verbose {
        println!("Array Before Sorting\n{:?}", &vector);
    }
    println!("\n{} sort start...", sort);
    let time = Instant::now();

    match sort {
        "bubble" => bubble_sort(vector, order),
        "shaker" => shaker_sort(vector, order),
        "insertion" => insertion_sort(vector, order),
        "gnome" => gnome_sort(vector, order),
        "merge" => merge_sort(vector, order),
        _ => {
            println!(
                "Error: \"{}\" sort algorithm is not implemented or not exists.",
                sort
            );
            process::exit(1);
        }
    }

    println!("{} sort finish with time {:?}", sort, Instant::now() - time);
    if verbose {
        println!("\nArray After Sorting\n{:?}", &vector);
    }
}
